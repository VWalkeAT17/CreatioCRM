{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "additionalProperties": false,
  "properties": {
    "description": {
      "description": "A natural language explanation of the generated component.\r\nExample. \"This chart can be used for showing count of something.\"",
      "type": "string"
    },
    "details": {
      "description": "Markdown formatting rules for analytics component metadata.\r\nThe goal is to generate clean, structured Markdown with bold section headers and proper indentation.\r\n\r\nFormat Rules:\r\n- Each section must start with **<Name>:**\r\n- Do not include empty sections.\r\n- The allowed order of sections is always:\r\n1. Data Source (required)\r\n2. Aggregation\r\n3. Grouping\r\n4. Filters\r\n5. Series (if present, always last)\r\n\r\nExample:\r\n\r\n**Data Source:**\r\n- Opportunity\r\n\r\n**Aggregation:**\r\n- COUNT(Id)\r\n\r\n**Grouping:**\r\n- by CloseReasonId\r\n\r\n**Series:**\r\n- Won\r\n- Lost",
      "type": "string"
    },
    "element": {
      "$ref": "#/$defs/LLMListWidgetConfig"
    }
  },
  "required": [
    "description",
    "details",
    "element"
  ],
  "type": "object",
  "$defs": {
    "BackwardReferenceAggregationType": {
      "description": "Defines how records in backward reference relation should be aggregated.\r\nIf user didn't mention any counts, use aggregation type EXISTS (or NOT_EXISTS), if applicable.",
      "enum": [
        "COUNT",
        "SUM",
        "MIN",
        "MAX",
        "AVG",
        "EXISTS",
        "NOT_EXISTS"
      ],
      "type": "string"
    },
    "BackwardReferenceComparisonType": {
      "description": "Defines how records in backward reference relation should be compared.\r\nIf user asks to filter by column with date-related values, or mentions some numeric value you cannot use NULL.\r\nuse EQUAL if aggregationType is EXISTS or NOT_EXISTS.",
      "enum": [
        "EQUAL",
        "NOT_EQUAL",
        "LESS",
        "LESS_OR_EQUAL",
        "GREATER",
        "GREATER_OR_EQUAL"
      ],
      "type": "string"
    },
    "BackwardReferenceFilter": {
      "additionalProperties": false,
      "description": "Use it when you need to filter entities with backward reference relation.\r\n\r\n**Core Concept:** Column paths define entity relationships and data access routes. Backward reference creates\r\none-to-many relationships where each root record can have multiple related records that must be aggregated.\r\n\r\n**Column Path Pattern:** `[JoinedTable:JoinedTableRelationColumn].JoinedTableColumn`\r\n- Creates one-to-many relationship from root table to related entities\r\n- Can be chained with forward references for multi-step relationships\r\n\r\nExample 1: \"accounts which have at least one contact\".\r\nIn this example:\r\nroot table is `Account`\r\njoined table is `Contact`\r\nlookup column of joined table that refers to root table is `AccountId` (in Contact table)\r\ncolumn of joined table to aggregate is `Id` (in Contact table)\r\nso, the config will be:\r\n{\r\n\"columnPath\": \"[Contact:AccountId].Id\",\r\n\"aggregationType\": \"EXISTS\",\r\n}\r\n\r\nExample 2: \"accounts where contacts average age < 30\".\r\nIn this example:\r\nroot table is `Account`\r\njoined table is `Contact`\r\nlookup column of joined table that refers to root table is `AccountId` (in Contact table)\r\ncolumn of joined table to aggregate is `Age` (in Contact table)\r\nso, the config will be:\r\n{\r\n\"columnPath\": \"[Contact:AccountId].Age\",\r\n\"aggregationType\": \"AVG\",\r\n\"comparisonType\": \"LESS\",\r\n\"aggregationValue\": \"30\"\r\n}\r\n\r\nExample 3 (with subFilters): \"accounts which have at least one contact older than 30\".\r\nIn this example:\r\nroot table is `Account`\r\njoined table is `Contact`\r\nlookup column of joined table that refers to root table is `AccountId` (in Contact table)\r\ncolumn of joined table to aggregate is `Id` (in Contact table)\r\nalso it will have subFilter on `Age` column in joined table `Contact`\r\nso, the config will be:\r\n{\r\n\"columnPath\": \"[Contact:AccountId].Id\",\r\n\"aggregationType\": \"EXISTS\",\r\n\"subFilters\": {\r\n\"logicalOperation\": \"AND\",\r\n\"filters\": [\r\n{ \"columnPath\": \"Age\", \"comparisonType\": \"GREATER\", \"value\": 30 }\r\n]\r\n}\r\nPay attention columnPath in subFilters does not use bracket notation, because you are already inside the context of the related entity.\r\n\r\nExample 4: \"employees who have at least one assigned case\".\r\nIn this example:\r\nroot table is `Employee`\r\njoined table is `Case`\r\n`Employee` and `Case` are not related directly, but they are related through `Contact` table\r\n`Employee` refers to `Contact` through `ContactId` column (forward reference)\r\n`Case` refers to `Contact` through `AssigneeId` column (backward reference)\r\nso, the config will be:\r\n{\r\n\"columnPath\": \"ContactId.[Case:AssigneeId].Id\",\r\n\"aggregationType\": \"EXISTS\"\r\n}\r\nThis creates a mixed reference: forward to Contact, then backward to Cases assigned to that Contact.",
      "properties": {
        "aggregationType": {
          "$ref": "#/$defs/BackwardReferenceAggregationType"
        },
        "aggregationValue": {
          "description": "value to compare with the result of aggregation.\r\nAlways provide a value for aggregation types COUNT, SUM, MIN, MAX, AVG.\r\nExample 1 (COUNT): Show count of accounts which have more than 10 cases - value will be \"10\".\r\nExample 2 (AVG): Show count of accounts which have first created case in 2023 - value will be \"2023-01-01T00:00:00Z\"\r\nExample 3 (EXISTS): show count of accounts which has cases - value is not needed,\r\nbecause user does not specify any value to compare with and asked\r\ncheck if any row satisfies the condition.",
          "type": "string"
        },
        "columnPath": {
          "description": "Column path that defines the relationship and data access route for backward reference.\r\nUses bracket notation format: \"[JoinedTable:JoinedTableRelationColumn].JoinedTableColumn\".\r\nCan be chained with forward references for multi-step relationships.\r\n\r\n**Pattern Examples:**\r\n- Simple backward reference: \"[Contact:AccountId].Id\" (find Contacts where AccountId equals current Account's ID)\r\n- Mixed reference: \"ContactId.[Case:AssigneeId].Id\" (forward to Contact → backward to Cases assigned to that Contact)\r\n\r\nExample 1: \"accounts which have more than 10 contacts\".\r\nIn this example:\r\nroot table is `Account`\r\njoined table is `Contact`\r\nlookup column of joined table that refers to root table is `AccountId` (in Contact table)\r\ncolumn of joined table to aggregate is `Id` (in Contact table)\r\nso, the columnPath will be \"[Contact:AccountId].Id\".",
          "type": "string"
        },
        "comparisonType": {
          "$ref": "#/$defs/BackwardReferenceComparisonType"
        },
        "subFilters": {
          "$ref": "#/$defs/FilterGroup"
        }
      },
      "required": [
        "columnPath",
        "comparisonType",
        "aggregationType",
        "aggregationValue",
        "subFilters"
      ],
      "type": "object"
    },
    "BooleanComparisonFilter": {
      "additionalProperties": false,
      "properties": {
        "columnPath": {
          "description": "name of column to filter by. By default, it is a column name, for example \"Age\"",
          "type": "string"
        },
        "comparisonType": {
          "const": "EQUAL",
          "type": "string"
        },
        "value": {
          "description": "Boolean value to compare with. For example, true or false",
          "type": "boolean"
        }
      },
      "required": [
        "columnPath",
        "comparisonType",
        "value"
      ],
      "type": "object"
    },
    "DateComparisonFilter": {
      "additionalProperties": false,
      "description": "Filter for comparing columns with date.\r\nUse it when you need to compare with absolute date. Do not use it for relative dates",
      "properties": {
        "columnPath": {
          "description": "name of column to filter by. By default, it is a column name, for example \"Age\"",
          "type": "string"
        },
        "comparisonType": {
          "$ref": "#/$defs/DateComparisonType"
        },
        "value": {
          "description": "Date in ISO format, for example \"2023-10-01T00:00:00Z\"",
          "type": "string"
        }
      },
      "required": [
        "columnPath",
        "comparisonType",
        "value"
      ],
      "type": "object"
    },
    "DateComparisonType": {
      "enum": [
        "EQUAL",
        "NOT_EQUAL",
        "LESS",
        "LESS_OR_EQUAL",
        "GREATER",
        "GREATER_OR_EQUAL"
      ],
      "type": "string"
    },
    "FilterGroup": {
      "additionalProperties": false,
      "description": "Group of filters, which can be combined by logical operation.\r\nFilter group can contain other filter groups.",
      "properties": {
        "backwardReferenceFilters": {
          "description": "if you need to filter by backward reference relation, use this property.",
          "items": {
            "$ref": "#/$defs/BackwardReferenceFilter"
          },
          "type": "array"
        },
        "filters": {
          "items": {
            "anyOf": [
              {
                "$ref": "#/$defs/BooleanComparisonFilter"
              },
              {
                "$ref": "#/$defs/MathComparisonFilter"
              },
              {
                "$ref": "#/$defs/StringComparisonFilter"
              },
              {
                "$ref": "#/$defs/DateComparisonFilter"
              },
              {
                "$ref": "#/$defs/RelativeDateComparisonFilter"
              },
              {
                "$ref": "#/$defs/LookupComparisonFilter"
              },
              {
                "$ref": "#/$defs/IsNullComparisonFilter"
              },
              {
                "$ref": "#/$defs/IsNotNullComparisonFilter"
              },
              {
                "$ref": "#/$defs/FilterGroup"
              }
            ]
          },
          "type": "array"
        },
        "logicalOperation": {
          "description": "Logical operation to combine filters in the group. Default is \"AND\"",
          "enum": [
            "AND",
            "OR"
          ],
          "type": "string"
        }
      },
      "required": [
        "filters",
        "backwardReferenceFilters",
        "logicalOperation"
      ],
      "type": "object"
    },
    "IsNotNullComparisonFilter": {
      "additionalProperties": false,
      "description": "Filter for comparing columns with not null values.\r\nUse it when you need to check if a column is not null.",
      "properties": {
        "columnPath": {
          "description": "name of column to filter by. By default, it is a column name, for example \"Age\"",
          "type": "string"
        },
        "comparisonType": {
          "const": "IS_NOT_NULL",
          "type": "string"
        }
      },
      "required": [
        "columnPath",
        "comparisonType"
      ],
      "type": "object"
    },
    "IsNullComparisonFilter": {
      "additionalProperties": false,
      "description": "Filter for comparing columns with null values.\r\nUse it when you need to check if a column is null.",
      "properties": {
        "columnPath": {
          "description": "name of column to filter by. By default, it is a column name, for example \"Age\"",
          "type": "string"
        },
        "comparisonType": {
          "const": "IS_NULL",
          "type": "string"
        }
      },
      "required": [
        "columnPath",
        "comparisonType"
      ],
      "type": "object"
    },
    "LLMAggregatedColumn": {
      "additionalProperties": false,
      "description": "Used to define list columns that aggregate data from related entities (e.g., count of related records).\r\nUses backward reference column paths to create one-to-many relationships that require aggregation.\r\nAlways specify an aggregation function, as backward reference columns are used for aggregation.\r\n\r\n**Core Concept:** Column paths define entity relationships and data access routes. Backward reference creates\r\none-to-many relationships where each root record can have multiple related records that must be aggregated.\r\n\r\n**Column Path Pattern:** `[JoinedTable:JoinedTableRelationColumn].JoinedTableColumn`\r\n- Creates one-to-many relationship from root table to joined table.\r\n- Can be chained with forward references for multi-step relationships\r\n\r\nExample 1: Count of contacts for each account:\r\n{\r\ncolumnPath: '[Contact:AccountId].Id',\r\naggregationFunction: 'COUNT',\r\nfilter: { ... },\r\ncolumnCaption: 'Number of Contacts'\r\n}\r\n\r\nExample 2: Sum of order amounts for each contact:\r\n{\r\ncolumnPath: '[Order:ContactId].TotalAmount',\r\naggregationFunction: 'SUM',\r\nfilter: { ... },\r\ncolumnCaption: 'Total Orders Amount'\r\n}",
      "properties": {
        "aggregationFunction": {
          "description": "Aggregation function to apply to the referenced data.\r\nCan be one of: 'COUNT', 'SUM', 'AVG', 'MIN', 'MAX'.",
          "enum": [
            "COUNT",
            "SUM",
            "AVG",
            "MIN",
            "MAX"
          ],
          "type": "string"
        },
        "columnCaption": {
          "description": "User-friendly caption for the column.",
          "type": "string"
        },
        "columnPath": {
          "description": "Column path that defines the relationship and data access route for backward reference aggregation.\r\nUses bracket notation format: \"[JoinedTable:JoinedTableRelationColumn].JoinedTableColumn\".\r\nCan be chained with forward references for multi-step relationships.\r\n\r\n**Pattern Examples:**\r\n- Simple backward reference: \"[Contact:AccountId].Id\" (find Contacts where AccountId equals current Account's ID)\r\n- Mixed reference: \"ContactId.[Order:ContactId].TotalAmount\" (forward to Contact → backward to Orders for that Contact)\r\n\r\nExample 1: \"accounts which have more than 10 contacts\".\r\n- root table: Account\r\n- joined table: Contact\r\n- lookup column of related table that refers to root table: AccountId (in Contact table)\r\n- column of related table to aggregate: Id (in Contact table)\r\n- columnPath: \"[Contact:AccountId].Id\"\r\n\r\nExample 2: \"accounts where contacts total order amount > 1000\".\r\n- root table: Account\r\n- joined table: Order\r\n- lookup column: AccountId (in Order table)\r\n- column to aggregate: TotalAmount (in Order table)\r\n- columnPath: \"[Order:AccountId].TotalAmount\"",
          "type": "string"
        },
        "filter": {
          "$ref": "#/$defs/FilterGroup"
        }
      },
      "required": [
        "columnPath",
        "aggregationFunction",
        "filter",
        "columnCaption"
      ],
      "type": "object"
    },
    "LLMForwardReferenceColumn": {
      "additionalProperties": false,
      "description": "Used to define columns that directly reference fields in the main entity using forward reference paths.\r\nCreates one-to-one relationships through lookup columns using dot notation.\r\n\r\n**Core Concept:** Forward references build connections from root table to related tables through lookup columns.\r\n**Pattern:** `LookupColumn.Column` or just `Column` for direct fields.\r\n**Creates:** One-to-one relationship (each root record has exactly one related record through the lookup).\r\n\r\nExample 1: Direct reference to a contact's name:\r\n{\r\ncolumnPath: 'Name',\r\ncolumnCaption: 'Name'\r\n}\r\n\r\nExample 2: Direct reference to an account owner's name:\r\n{\r\ncolumnPath: 'AccountId.OwnerId',\r\ncolumnCaption: 'Account Owner'\r\n}\r\n\r\nExample 3: Chained forward reference through multiple lookups:\r\n{\r\ncolumnPath: 'AccountId.PrimaryContactId.Age',\r\ncolumnCaption: 'Primary Contact Age'\r\n}\r\n\r\nNever use backward reference path (with square brackets e.g. [Contact:AccountId].Id) in forward reference columns.",
      "properties": {
        "columnCaption": {
          "description": "User-friendly caption for the column.",
          "type": "string"
        },
        "columnPath": {
          "description": "Column path that defines the relationship and data access route for forward reference.\r\nUses dot notation for one-to-one relationships through lookup columns (direct reference, no aggregation).\r\nCan be chained through multiple lookup columns for multi-step relationships.\r\n\r\n**Pattern Examples:**\r\n- Direct field: \"Name\", \"CreatedOn\"\r\n- Single lookup: \"AccountId\", \"ContactId\" (prefer lookup itself for clickable links)\r\n- Chained lookups: \"AccountId.OwnerId\", \"AccountId.PrimaryContactId.Age\"\r\n\r\nPrefer the lookup column itself (e.g., \"AccountId\") over a string property (e.g., \"AccountId.Name\") so the widget renders a clickable link to the related record. String properties are shown as plain text.\r\nExamples: \"Name\", \"CreatedOn\", \"AccountId\", \"AccountId.OwnerId\"",
          "type": "string"
        }
      },
      "required": [
        "columnPath",
        "columnCaption"
      ],
      "type": "object"
    },
    "LLMListWidgetConfig": {
      "additionalProperties": false,
      "description": "Configuration for the LLM List Widget.",
      "properties": {
        "data": {
          "additionalProperties": false,
          "description": "Data configuration for the list widget.\r\nAlways include at least one column that represents the name or title of the entity.\r\nAlso include a column used for ordering the data.\r\n\r\nIf backward reference columns are used, ensure that it has aggregation function specified.\r\n\r\nDo not use filters for limiting the number of rows - use `rowsLimit` and `orderBy` properties instead.\r\nFor example, do not use \"Top 10 opportunities by amount\" filter - instead set `rowsLimit` to 10 and set `orderBy.columnPath` to `Amount`.",
          "properties": {
            "filters": {
              "$ref": "#/$defs/FilterGroup"
            },
            "from": {
              "description": "The name of the primary table.\r\nTable names examples: \"Account\", \"Contact\", \"Order\", \"Case\"\r\nExamples of primary table identification:\r\nExample 1: User prompt \"show me all contacts\" → primary table: `Contact`\r\nExample 2: User prompt \"show me contacts and their accounts\" → primary table: `Contact`\r\nExample 3: User prompt \"top accounts by number of contacts\" → primary table: `Account`\r\nExample 4: User prompt \"show me number of contacts by account\" → primary table: `Account`.\r\nPay attention that list widget does not support grouping by columns, so if user prompt implies grouping (e.g. \"show me number of contacts by account\"),\r\ninstead of choosing `Contact` as primary table and grouping by `Account`, you should choose `Account` as primary table and aggregate contacts (filtered by each account) by count.",
              "type": "string"
            },
            "orderBy": {
              "additionalProperties": false,
              "description": "Sorting configuration for the list widget.\r\nIf user didn't specify how to sort the data, use the following defaults:\r\n- Sort by the first column in the select array.\r\n- Sort direction is \"asc\".",
              "properties": {
                "columnPath": {
                  "description": "The column path to order by. Must be one of the columns in the `select` array.",
                  "type": "string"
                },
                "direction": {
                  "description": "The sort direction.",
                  "enum": [
                    "ASC",
                    "DESC"
                  ],
                  "type": "string"
                }
              },
              "required": [
                "columnPath",
                "direction"
              ],
              "type": "object"
            },
            "rowsLimit": {
              "description": "Maximum number of rows to display in the list widget.\r\nOptional. If not specified, will use default pagination settings.",
              "type": "number"
            },
            "select": {
              "items": {
                "anyOf": [
                  {
                    "$ref": "#/$defs/LLMForwardReferenceColumn"
                  },
                  {
                    "$ref": "#/$defs/LLMAggregatedColumn"
                  }
                ]
              },
              "type": "array"
            }
          },
          "required": [
            "select",
            "from",
            "filters",
            "orderBy",
            "rowsLimit"
          ],
          "type": "object"
        },
        "title": {
          "description": "The title text displayed in the widget header.\r\nIt should start with a capital letter, and all other words should be in lowercase (except proper nouns).\r\nDo not include time periods, such as \"(Last 2 Years)\", \"(Monthly)\", or similar phrases.",
          "type": "string"
        },
        "type": {
          "const": "crt.ListWidget",
          "description": "The type of the widget.\r\nUsed to identify the widget type in the system.",
          "type": "string"
        }
      },
      "required": [
        "type",
        "title",
        "data"
      ],
      "type": "object"
    },
    "LookupComparisonFilter": {
      "additionalProperties": false,
      "properties": {
        "columnPath": {
          "description": "name of column to filter by. By default, it is a column name, for example \"Age\"",
          "type": "string"
        },
        "comparisonType": {
          "$ref": "#/$defs/LookupComparisonType"
        },
        "value": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "items": {
                "type": "string"
              },
              "type": "array"
            }
          ],
          "description": "Id of the lookup value to compare with or array of ids.\r\nExamples:\r\n- \"59970ea3-1ee6-4b13-af5a-26908a5e3de4\"\r\n- [\"59970ea3-1ee6-4b13-af5a-26908a5e3de4\", \"69111d53-5d21-4133-913f-2d499c642d79\"]"
        }
      },
      "required": [
        "columnPath",
        "comparisonType",
        "value"
      ],
      "type": "object"
    },
    "LookupComparisonType": {
      "description": "Allows to compare column with lookup values (single or multiple).\r\nExample of comparing column with multiple lookup values:\r\n1. In case \"from USA or UK\"\r\nfilter should be `{\r\n\"columnPath\": \"CountryId\",\r\n\"comparisonType\": \"EQUAL\" ,\r\n\"value\": [\"f7bf32c8-f36b-1410-fc98-00155d043204\", \"69111d53-5d21-4133-913f-2d499c642d79\"]\r\n}`",
      "enum": [
        "EQUAL",
        "NOT_EQUAL",
        "EXISTS",
        "NOT_EXISTS"
      ],
      "type": "string"
    },
    "MathComparisonFilter": {
      "additionalProperties": false,
      "description": "Filter for comparing columns with numbers. Use it when you need to compare numbers.",
      "properties": {
        "columnPath": {
          "description": "name of column to filter by. By default, it is a column name, for example \"Age\"",
          "type": "string"
        },
        "comparisonType": {
          "$ref": "#/$defs/MathComparisonType"
        },
        "value": {
          "description": "Number value to compare with. For example, 125",
          "type": "number"
        }
      },
      "required": [
        "columnPath",
        "comparisonType",
        "value"
      ],
      "type": "object"
    },
    "MathComparisonType": {
      "enum": [
        "EQUAL",
        "NOT_EQUAL",
        "LESS",
        "LESS_OR_EQUAL",
        "GREATER",
        "GREATER_OR_EQUAL"
      ],
      "type": "string"
    },
    "RelativeDateComparisonFilter": {
      "additionalProperties": false,
      "description": "Filter for comparing columns with date.\r\nUse it when you need to compare with relative date. Do not use it for absolute dates.",
      "properties": {
        "columnPath": {
          "description": "name of column to filter by. By default, it is a column name, for example \"Age\"",
          "type": "string"
        },
        "comparisonType": {
          "$ref": "#/$defs/RelativeDateComparisonType"
        },
        "value": {
          "description": "function-calling string, which is composed of relative date parts.\r\nPart 1 can be \"PREVIOUS\", \"CURRENT\" or \"NEXT\",\r\npart 2 can be \"HOUR\", \"DAY\", \"WEEK\", \"MONTH\", \"QUARTER\", \"HALFYEAR\", \"YEAR\".\r\nBetween them is underscore \"_\". part 3 is call of the function with number as argument\r\nFor example, \"PREVIOUS_WEEK()\" or \"NEXT_MONTH()\".\r\nNote, Yesterday, Today, Tomorrow are cast to \"PREVIOUS_DAY()\", \"CURRENT_DAY()\" and \"NEXT_DAY()\"\r\nAlso, allowed functions are:\r\nDAY_OF_WEEK(n) - (example: \"DAY_OF_WEEK(2)\" means \"each Monday\"). n - number of day of week starting from Sunday:\r\n1 - Sunday, 2 - Monday, 3 - Tuesday, 4 - Wednesday, 5 - Thursday, 6 - Friday, 7 - Saturday.\r\nDAY_OF_MONTH(n) - (example: \"DAY_OF_MONTH(14)\" means \"each 14th day of the month\"),\r\nMONTH(n) - (example: \"MONTH(5)\" means \"each May\"),\r\nEXACT_YEAR(n) - (example: \"EXACT_YEAR(1985)\" means \"in 1985\"),\r\nEXACT_TIME(h,m,s) - (example: \"EXACT_TIME(15,20,0)\" means \"at 15:20:00\")\r\nWITHIN_PREV_HOURS(n), WITHIN_NEXT_HOURS(n) - means \"within the last n hours\" and \"within the next n hours\" respectively.\r\nWITHIN_PREV_DAYS(n), WITHIN_NEXT_DAYS(n) - means \"within the last n days\" and \"within the next n days\" respectively.\r\nANNIVERSARY_TODAY() - means \"each year, today\"\r\nANNIVERSARY_EXACTLY_IN_DAYS(n) - means \"each year, exactly in n days after today\"\r\nANNIVERSARY_WITHIN_NEXTDAYS(n) - means \"each year, within the next n days\"\r\nANNIVERSARY_WITHIN_PREVDAYS(n) - means \"each year, within the previous n days\"",
          "type": "string"
        }
      },
      "required": [
        "columnPath",
        "comparisonType",
        "value"
      ],
      "type": "object"
    },
    "RelativeDateComparisonType": {
      "description": "Specifics of working with periods:\r\nIf value is period (PREVIOUS_YEAR(), CURRENT_MONTH(), etc.),\r\nuse comparisonType \"EQUAL\" to check if the date is in that period.\r\nExample:\r\n1. In case \"created in the previous month\"\r\n\tfilter should be `{ \"columnPath\": \"CreatedOn\", \"comparisonType\": \"EQUAL\" , \"value\": \"PREVIOUS_MONTH()\" }`",
      "enum": [
        "EQUAL",
        "NOT_EQUAL",
        "LESS",
        "LESS_OR_EQUAL",
        "GREATER",
        "GREATER_OR_EQUAL"
      ],
      "type": "string"
    },
    "StringComparisonFilter": {
      "additionalProperties": false,
      "description": "Filter for comparing values.\r\nUse it when you need to compare strings. Do not use for dates.\r\nDo not use it for lookup filters.\r\nBut if lookup Id search fails, use lookup display name columns with format \"LookupEntity.DisplayColumn\".\r\n*Never* use \"CONTAIN\" with lookup column.",
      "properties": {
        "columnPath": {
          "description": "name of column to filter by. By default, it is a column name, for example \"Age\"",
          "type": "string"
        },
        "comparisonType": {
          "$ref": "#/$defs/StringComparisonType"
        },
        "value": {
          "description": "String value to compare with. For example, \"John Doe\"",
          "type": "string"
        }
      },
      "required": [
        "columnPath",
        "comparisonType",
        "value"
      ],
      "type": "object"
    },
    "StringComparisonType": {
      "enum": [
        "EQUAL",
        "NOT_EQUAL",
        "START_WITH",
        "NOT_START_WITH",
        "CONTAIN",
        "NOT_CONTAIN",
        "END_WITH",
        "NOT_END_WITH",
        "EXISTS",
        "NOT_EXISTS"
      ],
      "type": "string"
    }
  }
}