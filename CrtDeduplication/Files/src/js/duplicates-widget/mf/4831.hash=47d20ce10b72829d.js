(self.webpackChunkapp_studio_enterprise_duplicates_widget=self.webpackChunkapp_studio_enterprise_duplicates_widget||[]).push([[4831,7212],{7212:(O,y,c)=>{c.r(y),c.d(y,{outputFromObservable:()=>v,outputToObservable:()=>p,takeUntilDestroyed:()=>d,toObservable:()=>f,toSignal:()=>b});var e=c(22307),l=c(62278),g=c(36486);/**
 * @license Angular v18.2.14
 * (c) 2010-2024 Google LLC. https://angular.io/
 * License: MIT
 */function d(r){r||((0,e.assertInInjectionContext)(d),r=(0,e.inject)(e.DestroyRef));const t=new l.Observable(n=>r.onDestroy(n.next.bind(n)));return n=>n.pipe((0,g.takeUntil)(t))}class h{constructor(t){this.source=t,this.destroyed=!1,this.destroyRef=(0,e.inject)(e.DestroyRef),this.destroyRef.onDestroy(()=>{this.destroyed=!0})}subscribe(t){if(this.destroyed)throw new e.\u0275RuntimeError(953,ngDevMode&&"Unexpected subscription to destroyed `OutputRef`. The owning directive/component is destroyed.");const n=this.source.pipe(d(this.destroyRef)).subscribe({next:s=>t(s)});return{unsubscribe:()=>n.unsubscribe()}}}function v(r,t){return ngDevMode&&(0,e.assertInInjectionContext)(v),new h(r)}function p(r){const t=(0,e.\u0275getOutputDestroyRef)(r);return new l.Observable(n=>{t?.onDestroy(()=>n.complete());const s=r.subscribe(i=>n.next(i));return()=>s.unsubscribe()})}function f(r,t){!t?.injector&&(0,e.assertInInjectionContext)(f);const n=t?.injector??(0,e.inject)(e.Injector),s=new l.ReplaySubject(1),i=(0,e.effect)(()=>{let o;try{o=r()}catch(a){(0,e.untracked)(()=>s.error(a));return}(0,e.untracked)(()=>s.next(o))},{injector:n,manualCleanup:!0});return n.get(e.DestroyRef).onDestroy(()=>{i.destroy(),s.complete()}),s.asObservable()}function b(r,t){ngDevMode&&(0,e.assertNotInReactiveContext)(b,"Invoking `toSignal` causes new subscriptions every time. Consider moving `toSignal` outside of the reactive context and read the signal value where needed.");const n=!t?.manualCleanup;n&&!t?.injector&&(0,e.assertInInjectionContext)(b);const s=n?t?.injector?.get(e.DestroyRef)??(0,e.inject)(e.DestroyRef):null,i=D(t?.equal);let o;t?.requireSync?o=(0,e.signal)({kind:0},{equal:i}):o=(0,e.signal)({kind:1,value:t?.initialValue},{equal:i});const a=r.subscribe({next:u=>o.set({kind:1,value:u}),error:u=>{if(t?.rejectErrors)throw u;o.set({kind:2,error:u})}});if(t?.requireSync&&o().kind===0)throw new e.\u0275RuntimeError(601,(typeof ngDevMode>"u"||ngDevMode)&&"`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.");return s?.onDestroy(a.unsubscribe.bind(a)),(0,e.computed)(()=>{const u=o();switch(u.kind){case 1:return u.value;case 2:throw u.error;case 0:throw new e.\u0275RuntimeError(601,(typeof ngDevMode>"u"||ngDevMode)&&"`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.")}},{equal:t?.equal})}function D(r=Object.is){return(t,n)=>t.kind===1&&n.kind===1&&r(t.value,n.value)}}}]);
