(self.webpackChunkapp_studio_enterprise_error_list_dialog=self.webpackChunkapp_studio_enterprise_error_list_dialog||[]).push([[7212,4831],{7212:(O,y,c)=>{c.r(y),c.d(y,{outputFromObservable:()=>v,outputToObservable:()=>D,takeUntilDestroyed:()=>d,toObservable:()=>f,toSignal:()=>b});var e=c(22307),l=c(62278),g=c(36486);/**
 * @license Angular v18.2.14
 * (c) 2010-2024 Google LLC. https://angular.io/
 * License: MIT
 */function d(r){r||((0,e.assertInInjectionContext)(d),r=(0,e.inject)(e.DestroyRef));const t=new l.Observable(n=>r.onDestroy(n.next.bind(n)));return n=>n.pipe((0,g.takeUntil)(t))}class h{constructor(t){this.source=t,this.destroyed=!1,this.destroyRef=(0,e.inject)(e.DestroyRef),this.destroyRef.onDestroy(()=>{this.destroyed=!0})}subscribe(t){if(this.destroyed)throw new e.\u0275RuntimeError(953,ngDevMode&&"Unexpected subscription to destroyed `OutputRef`. The owning directive/component is destroyed.");const n=this.source.pipe(d(this.destroyRef)).subscribe({next:s=>t(s)});return{unsubscribe:()=>n.unsubscribe()}}}function v(r,t){return ngDevMode&&(0,e.assertInInjectionContext)(v),new h(r)}function D(r){const t=(0,e.\u0275getOutputDestroyRef)(r);return new l.Observable(n=>{t?.onDestroy(()=>n.complete());const s=r.subscribe(u=>n.next(u));return()=>s.unsubscribe()})}function f(r,t){!t?.injector&&(0,e.assertInInjectionContext)(f);const n=t?.injector??(0,e.inject)(e.Injector),s=new l.ReplaySubject(1),u=(0,e.effect)(()=>{let o;try{o=r()}catch(a){(0,e.untracked)(()=>s.error(a));return}(0,e.untracked)(()=>s.next(o))},{injector:n,manualCleanup:!0});return n.get(e.DestroyRef).onDestroy(()=>{u.destroy(),s.complete()}),s.asObservable()}function b(r,t){ngDevMode&&(0,e.assertNotInReactiveContext)(b,"Invoking `toSignal` causes new subscriptions every time. Consider moving `toSignal` outside of the reactive context and read the signal value where needed.");const n=!t?.manualCleanup;n&&!t?.injector&&(0,e.assertInInjectionContext)(b);const s=n?t?.injector?.get(e.DestroyRef)??(0,e.inject)(e.DestroyRef):null,u=p(t?.equal);let o;t?.requireSync?o=(0,e.signal)({kind:0},{equal:u}):o=(0,e.signal)({kind:1,value:t?.initialValue},{equal:u});const a=r.subscribe({next:i=>o.set({kind:1,value:i}),error:i=>{if(t?.rejectErrors)throw i;o.set({kind:2,error:i})}});if(t?.requireSync&&o().kind===0)throw new e.\u0275RuntimeError(601,(typeof ngDevMode>"u"||ngDevMode)&&"`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.");return s?.onDestroy(a.unsubscribe.bind(a)),(0,e.computed)(()=>{const i=o();switch(i.kind){case 1:return i.value;case 2:throw i.error;case 0:throw new e.\u0275RuntimeError(601,(typeof ngDevMode>"u"||ngDevMode)&&"`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.")}},{equal:t?.equal})}function p(r=Object.is){return(t,n)=>t.kind===1&&n.kind===1&&r(t.value,n.value)}}}]);
