(self.webpackChunkapp_studio_enterprise_schema_view=self.webpackChunkapp_studio_enterprise_schema_view||[]).push([[7985,3308],{57985:(re,A,h)=>{var p;h.r(A),h.d(A,{ComponentFixture:()=>L,ComponentFixtureAutoDetect:()=>B,ComponentFixtureNoNgZone:()=>x,DeferBlockBehavior:()=>r.\u0275DeferBlockBehavior,DeferBlockFixture:()=>f,DeferBlockState:()=>r.\u0275DeferBlockState,InjectSetupWrapper:()=>X,TestBed:()=>q,TestComponentRenderer:()=>U,__core_private_testing_placeholder__:()=>ke,discardPeriodicTasks:()=>ue,fakeAsync:()=>ae,flush:()=>de,flushMicrotasks:()=>he,getTestBed:()=>Pe,inject:()=>Y,resetFakeAsyncZone:()=>ie,tick:()=>le,waitForAsync:()=>w,withModule:()=>Fe,\u0275MetadataOverrider:()=>z});var m=h(73308),r=h(22307),D=h(62278),R=h(8149);/**
 * @license Angular v18.2.14
 * (c) 2010-2024 Google LLC. https://angular.io/
 * License: MIT
 */function w(s){const e=typeof Zone<"u"?Zone:null;if(!e)return function(){return Promise.reject("Zone is needed for the waitForAsync() test helper but could not be found. Please make sure that your environment includes zone.js")};const t=e&&e[e.__symbol__("asyncTest")];return typeof t=="function"?t(s):function(){return Promise.reject("zone-testing.js is needed for the async() test helper but could not be found. Please make sure that your environment includes zone.js/testing")}}class f{constructor(e,t){this.block=e,this.componentFixture=t}render(e){var t=this;return(0,m.A)(function*(){if(!T(e,t.block)){const o=_(e);throw new Error(`Tried to render this defer block in the \`${o}\` state, but there was no @${o.toLowerCase()} block defined in a template.`)}e===r.\u0275DeferBlockState.Complete&&(yield(0,r.\u0275triggerResourceLoading)(t.block.tDetails,t.block.lView,t.block.tNode)),(0,r.\u0275renderDeferBlockState)(e,t.block.tNode,t.block.lContainer,!0),t.componentFixture.detectChanges()})()}getDeferBlocks(){const e=[],t=[];if(this.block.lContainer.length>=r.\u0275CONTAINER_HEADER_OFFSET){const n=this.block.lContainer[r.\u0275CONTAINER_HEADER_OFFSET];(0,r.\u0275getDeferBlocks)(n,e);for(const o of e)t.push(new f(o,this.componentFixture))}return Promise.resolve(t)}}function T(s,e){switch(s){case r.\u0275DeferBlockState.Placeholder:return e.tDetails.placeholderTmplIndex!==null;case r.\u0275DeferBlockState.Loading:return e.tDetails.loadingTmplIndex!==null;case r.\u0275DeferBlockState.Error:return e.tDetails.errorTmplIndex!==null;case r.\u0275DeferBlockState.Complete:return!0;default:return!1}}function _(s){switch(s){case r.\u0275DeferBlockState.Placeholder:return"Placeholder";case r.\u0275DeferBlockState.Loading:return"Loading";case r.\u0275DeferBlockState.Error:return"Error";default:return"Main"}}const g=!0,v=!1,S=!1,N=r.\u0275DeferBlockBehavior.Playthrough;class U{insertRootElement(e){}removeAllRootElements(){}}const B=new r.InjectionToken("ComponentFixtureAutoDetect"),x=new r.InjectionToken("ComponentFixtureNoNgZone"),G=new r.InjectionToken("rethrow application errors");class O{constructor(){this.zone=(0,r.inject)(r.NgZone),this.userErrorHandler=(0,r.inject)(r.ErrorHandler),this.whenStableRejectFunctions=new Set}handleError(e){try{this.zone.runOutsideAngular(()=>this.userErrorHandler.handleError(e))}catch(t){e=t}if(this.whenStableRejectFunctions.size>0){for(const t of this.whenStableRejectFunctions.values())t(e);this.whenStableRejectFunctions.clear()}else throw e}static{this.\u0275fac=r.\u0275\u0275ngDeclareFactory({minVersion:"12.0.0",version:"18.2.14",ngImport:p||(p=h.t(r,2)),type:O,deps:[],target:r.\u0275\u0275FactoryTarget.Injectable})}static{this.\u0275prov=r.\u0275\u0275ngDeclareInjectable({minVersion:"12.0.0",version:"18.2.14",ngImport:p||(p=h.t(r,2)),type:O})}}r.\u0275\u0275ngDeclareClassMetadata({minVersion:"12.0.0",version:"18.2.14",ngImport:p||(p=h.t(r,2)),type:O,decorators:[{type:r.Injectable}]});class L{constructor(e){this.componentRef=e,this._isDestroyed=!1,this._noZoneOptionIsSet=(0,r.inject)(x,{optional:!0}),this._ngZone=this._noZoneOptionIsSet?new r.\u0275NoopNgZone:(0,r.inject)(r.NgZone),this._effectRunner=(0,r.inject)(r.\u0275EffectScheduler),this._appRef=(0,r.inject)(r.ApplicationRef),this._testAppRef=this._appRef,this.pendingTasks=(0,r.inject)(r.\u0275PendingTasks),this.appErrorHandler=(0,r.inject)(O),this.ngZone=this._noZoneOptionIsSet?null:this._ngZone,this.changeDetectorRef=e.changeDetectorRef,this.elementRef=e.location,this.debugElement=(0,r.getDebugNode)(this.elementRef.nativeElement),this.componentInstance=e.instance,this.nativeElement=this.elementRef.nativeElement,this.componentRef=e}checkNoChanges(){this.changeDetectorRef.checkNoChanges()}isStable(){return!this.pendingTasks.hasPendingTasks.value}whenStable(){return this.isStable()?Promise.resolve(!1):new Promise((e,t)=>{this.appErrorHandler.whenStableRejectFunctions.add(t),this._appRef.whenStable().then(()=>{this.appErrorHandler.whenStableRejectFunctions.delete(t),e(!0)})})}getDeferBlocks(){const e=[],t=this.componentRef.hostView._lView;(0,r.\u0275getDeferBlocks)(t,e);const n=[];for(const o of e)n.push(new f(o,this));return Promise.resolve(n)}_getRenderer(){return this._renderer===void 0&&(this._renderer=this.componentRef.injector.get(r.RendererFactory2,null)),this._renderer}whenRenderingDone(){const e=this._getRenderer();return e&&e.whenRenderingDone?e.whenRenderingDone():this.whenStable()}destroy(){this._isDestroyed||(this.componentRef.destroy(),this._isDestroyed=!0)}}class oe extends L{constructor(){super(...arguments),this._autoDetect=(0,r.inject)(B,{optional:!0})??!0}initialize(){this._autoDetect&&this._appRef.attachView(this.componentRef.hostView)}detectChanges(e=!0){if(!e)throw new Error("Cannot disable `checkNoChanges` in this configuration. Use `fixture.componentRef.hostView.changeDetectorRef.detectChanges()` instead.");this._effectRunner.flush(),this._appRef.tick(),this._effectRunner.flush()}autoDetectChanges(e=!0){if(e)this._autoDetect||(this._autoDetect=e,this._appRef.attachView(this.componentRef.hostView));else throw new Error("Cannot disable autoDetect after it has been enabled when using the zoneless scheduler. To disable autoDetect, add `{provide: ComponentFixtureAutoDetect, useValue: false}` to the TestBed providers.");this.detectChanges()}}class se extends L{constructor(){super(...arguments),this._subscriptions=new D.Subscription,this._autoDetect=(0,r.inject)(B,{optional:!0})??!1,this.afterTickSubscription=void 0,this.beforeRenderSubscription=void 0}initialize(){this._autoDetect&&this.subscribeToAppRefEvents(),this.componentRef.hostView.onDestroy(()=>{this.unsubscribeFromAppRefEvents()}),this._ngZone.runOutsideAngular(()=>{this._subscriptions.add(this._ngZone.onError.subscribe({next:e=>{throw e}}))})}detectChanges(e=!0){this._effectRunner.flush(),this._ngZone.run(()=>{this.changeDetectorRef.detectChanges(),e&&this.checkNoChanges()}),this._effectRunner.flush()}autoDetectChanges(e=!0){if(this._noZoneOptionIsSet)throw new Error("Cannot call autoDetectChanges when ComponentFixtureNoNgZone is set.");e!==this._autoDetect&&(e?this.subscribeToAppRefEvents():this.unsubscribeFromAppRefEvents()),this._autoDetect=e,this.detectChanges()}subscribeToAppRefEvents(){this._ngZone.runOutsideAngular(()=>{this.afterTickSubscription=this._testAppRef.afterTick.subscribe(()=>{this.checkNoChanges()}),this.beforeRenderSubscription=this._testAppRef.beforeRender.subscribe(e=>{try{(0,r.\u0275detectChangesInViewIfRequired)(this.componentRef.hostView._lView,this.componentRef.hostView.notifyErrorHandler,e,!1)}catch(t){throw this.unsubscribeFromAppRefEvents(),t}}),this._testAppRef.externalTestViews.add(this.componentRef.hostView)})}unsubscribeFromAppRefEvents(){this.afterTickSubscription?.unsubscribe(),this.beforeRenderSubscription?.unsubscribe(),this.afterTickSubscription=void 0,this.beforeRenderSubscription=void 0,this._testAppRef.externalTestViews.delete(this.componentRef.hostView)}destroy(){this.unsubscribeFromAppRefEvents(),this._subscriptions.unsubscribe(),super.destroy()}}const V=typeof Zone<"u"?Zone:null,d=V&&V[V.__symbol__("fakeAsyncTest")],M=`zone-testing.js is needed for the fakeAsync() test helper but could not be found.
        Please make sure that your environment includes zone.js/testing`;function ie(){if(d)return d.resetFakeAsyncZone();throw new Error(M)}function ce(){d&&d.resetFakeAsyncZone()}function ae(s,e){if(d)return d.fakeAsync(s,e);throw new Error(M)}function le(s=0,e={processNewMacroTasksSynchronously:!0}){if(d)return d.tick(s,e);throw new Error(M)}function de(s){if(d)return d.flush(s);throw new Error(M)}function ue(){if(d)return d.discardPeriodicTasks();throw new Error(M)}function he(){if(d)return d.flushMicrotasks();throw new Error(M)}let pe=0;class z{constructor(){this._references=new Map}overrideMetadata(e,t,n){const o={};if(t&&Ee(t).forEach(i=>o[i]=t[i]),n.set){if(n.remove||n.add)throw new Error(`Cannot set and add/remove ${(0,r.\u0275stringify)(e)} at the same time!`);me(o,n.set)}return n.remove&&fe(o,n.remove,this._references),n.add&&ve(o,n.add),new e(o)}}function fe(s,e,t){const n=new Set;for(const o in e){const i=e[o];Array.isArray(i)?i.forEach(c=>{n.add(P(o,c,t))}):n.add(P(o,i,t))}for(const o in s){const i=s[o];Array.isArray(i)?s[o]=i.filter(c=>!n.has(P(o,c,t))):n.has(P(o,i,t))&&(s[o]=void 0)}}function ve(s,e){for(const t in e){const n=e[t],o=s[t];o!=null&&Array.isArray(o)?s[t]=o.concat(n):s[t]=n}}function me(s,e){for(const t in e)s[t]=e[t]}function P(s,e,t){let n=0;const o=new Map;return`${s}:${JSON.stringify(e,(c,a)=>a!==null&&typeof a=="object"?o.has(a)?o.get(a):(o.set(a,`\u0275obj#${n++}`),a):(typeof a=="function"&&(a=ge(a,t)),a))}`}function ge(s,e){let t=e.get(s);return t||(t=`${(0,r.\u0275stringify)(s)}${pe++}`,e.set(s,t)),t}function Ee(s){const e=[];Object.keys(s).forEach(n=>{n.startsWith("_")||e.push(n)});let t=s;for(;t=Object.getPrototypeOf(t);)Object.keys(t).forEach(n=>{const o=Object.getOwnPropertyDescriptor(t,n);!n.startsWith("_")&&o&&"get"in o&&e.push(n)});return e}const _e=new r.\u0275ReflectionCapabilities;class F{constructor(){this.overrides=new Map,this.resolved=new Map}addOverride(e,t){const n=this.overrides.get(e)||[];n.push(t),this.overrides.set(e,n),this.resolved.delete(e)}setOverrides(e){this.overrides.clear(),e.forEach(([t,n])=>{this.addOverride(t,n)})}getAnnotation(e){const t=_e.annotations(e);for(let n=t.length-1;n>=0;n--){const o=t[n];if(o instanceof r.Directive||o instanceof r.Component||o instanceof r.Pipe||o instanceof r.NgModule)return o instanceof this.type?o:null}return null}resolve(e){let t=this.resolved.get(e)||null;if(!t){if(t=this.getAnnotation(e),t){const n=this.overrides.get(e);if(n){const o=new z;n.forEach(i=>{t=o.overrideMetadata(this.type,t,i)})}}this.resolved.set(e,t)}return t}}class Oe extends F{get type(){return r.Directive}}class Ce extends F{get type(){return r.Component}}class we extends F{get type(){return r.Pipe}}class Te extends F{get type(){return r.NgModule}}var C;(function(s){s[s.DECLARATION=0]="DECLARATION",s[s.OVERRIDE_TEMPLATE=1]="OVERRIDE_TEMPLATE"})(C||(C={}));function Me(s){return s===C.DECLARATION||s===C.OVERRIDE_TEMPLATE}function $(s,e,t){s.forEach(n=>{if(!(0,r.\u0275getAsyncClassMetadataFn)(n)){const o=e.resolve(n);if(o&&o.standalone)throw new Error((0,r.\u0275generateStandaloneInDeclarationsError)(n,t))}})}class H{constructor(e,t){this.platform=e,this.additionalModuleTypes=t,this.originalComponentResolutionQueue=null,this.declarations=[],this.imports=[],this.providers=[],this.schemas=[],this.pendingComponents=new Set,this.pendingDirectives=new Set,this.pendingPipes=new Set,this.componentsWithAsyncMetadata=new Set,this.seenComponents=new Set,this.seenDirectives=new Set,this.overriddenModules=new Set,this.existingComponentStyles=new Map,this.resolvers=ye(),this.componentToModuleScope=new Map,this.initialNgDefs=new Map,this.defCleanupOps=[],this._injector=null,this.compilerProviders=null,this.providerOverrides=[],this.rootProviderOverrides=[],this.providerOverridesByModule=new Map,this.providerOverridesByToken=new Map,this.scopesWithOverriddenProviders=new Set,this.testModuleRef=null,this.deferBlockBehavior=N;class n{}this.testModuleType=n}setCompilerProviders(e){this.compilerProviders=e,this._injector=null}configureTestingModule(e){e.declarations!==void 0&&($(e.declarations,this.resolvers.component,'"TestBed.configureTestingModule" call'),this.queueTypeArray(e.declarations,C.DECLARATION),this.declarations.push(...e.declarations)),e.imports!==void 0&&(this.queueTypesFromModulesArray(e.imports),this.imports.push(...e.imports)),e.providers!==void 0&&this.providers.push(...e.providers),this.providers.push({provide:G,useValue:e._rethrowApplicationTickErrors??!1}),e.schemas!==void 0&&this.schemas.push(...e.schemas),this.deferBlockBehavior=e.deferBlockBehavior??N}overrideModule(e,t){r.\u0275USE_RUNTIME_DEPS_TRACKER_FOR_JIT&&r.\u0275depsTracker.clearScopeCacheFor(e),this.overriddenModules.add(e),this.resolvers.module.addOverride(e,t);const n=this.resolvers.module.resolve(e);if(n===null)throw j(e.name,"NgModule");this.recompileNgModule(e,n),this.queueTypesFromModulesArray([e])}overrideComponent(e,t){this.verifyNoStandaloneFlagOverrides(e,t),this.resolvers.component.addOverride(e,t),this.pendingComponents.add(e),this.maybeRegisterComponentWithAsyncMetadata(e)}overrideDirective(e,t){this.verifyNoStandaloneFlagOverrides(e,t),this.resolvers.directive.addOverride(e,t),this.pendingDirectives.add(e)}overridePipe(e,t){this.verifyNoStandaloneFlagOverrides(e,t),this.resolvers.pipe.addOverride(e,t),this.pendingPipes.add(e)}verifyNoStandaloneFlagOverrides(e,t){if(t.add?.hasOwnProperty("standalone")||t.set?.hasOwnProperty("standalone")||t.remove?.hasOwnProperty("standalone"))throw new Error(`An override for the ${e.name} class has the \`standalone\` flag. Changing the \`standalone\` flag via TestBed overrides is not supported.`)}overrideProvider(e,t){let n;t.useFactory!==void 0?n={provide:e,useFactory:t.useFactory,deps:t.deps||[],multi:t.multi}:t.useValue!==void 0?n={provide:e,useValue:t.useValue,multi:t.multi}:n={provide:e};const o=typeof e!="string"?(0,r.\u0275getInjectableDef)(e):null,i=o===null?null:(0,r.resolveForwardRef)(o.providedIn);if((i==="root"?this.rootProviderOverrides:this.providerOverrides).push(n),this.providerOverridesByToken.set(e,n),o!==null&&i!==null&&typeof i!="string"){const a=this.providerOverridesByModule.get(i);a!==void 0?a.push(n):this.providerOverridesByModule.set(i,[n])}}overrideTemplateUsingTestingModule(e,t){const n=e[r.\u0275NG_COMP_DEF],o=()=>{const a=this.resolvers.component.resolve(e);return!!a.styleUrl||!!a.styleUrls?.length},i=!!n&&!(0,r.\u0275isComponentDefPendingResolution)(e)&&o(),c=i?{template:t,styles:[],styleUrls:[],styleUrl:void 0}:{template:t};this.overrideComponent(e,{set:c}),i&&n.styles&&n.styles.length>0&&this.existingComponentStyles.set(e,n.styles),this.componentToModuleScope.set(e,C.OVERRIDE_TEMPLATE)}resolvePendingComponentsWithAsyncMetadata(){var e=this;return(0,m.A)(function*(){if(e.componentsWithAsyncMetadata.size===0)return;const t=[];for(const i of e.componentsWithAsyncMetadata){const c=(0,r.\u0275getAsyncClassMetadataFn)(i);c&&t.push(c())}e.componentsWithAsyncMetadata.clear();const o=(yield Promise.all(t)).flat(2);e.queueTypesFromModulesArray(o);for(const i of o)e.applyProviderOverridesInScope(i)})()}compileComponents(){var e=this;return(0,m.A)(function*(){if(e.clearComponentResolutionQueue(),yield e.resolvePendingComponentsWithAsyncMetadata(),$(e.declarations,e.resolvers.component,'"TestBed.configureTestingModule" call'),e.compileTypesSync()){let n,o=i=>(n||(n=e.injector.get(R.ResourceLoader)),Promise.resolve(n.get(i)));yield(0,r.\u0275resolveComponentResources)(o)}})()}finalize(){this.compileTypesSync(),this.compileTestModule(),this.applyTransitiveScopes(),this.applyProviderOverrides(),this.patchComponentsWithExistingStyles(),this.componentToModuleScope.clear();const e=this.platform.injector;this.testModuleRef=new r.\u0275Render3NgModuleRef(this.testModuleType,e,[]),this.testModuleRef.injector.get(r.ApplicationInitStatus).runInitializers();const t=this.testModuleRef.injector.get(r.LOCALE_ID,r.\u0275DEFAULT_LOCALE_ID);return(0,r.\u0275setLocaleId)(t),this.testModuleRef}_compileNgModuleSync(e){this.queueTypesFromModulesArray([e]),this.compileTypesSync(),this.applyProviderOverrides(),this.applyProviderOverridesInScope(e),this.applyTransitiveScopes()}_compileNgModuleAsync(e){var t=this;return(0,m.A)(function*(){t.queueTypesFromModulesArray([e]),yield t.compileComponents(),t.applyProviderOverrides(),t.applyProviderOverridesInScope(e),t.applyTransitiveScopes()})()}_getModuleResolver(){return this.resolvers.module}_getComponentFactories(e){return E(e.\u0275mod.declarations).reduce((t,n)=>{const o=n.\u0275cmp;return o&&t.push(new r.\u0275Render3ComponentFactory(o,this.testModuleRef)),t},[])}compileTypesSync(){let e=!1;return this.pendingComponents.forEach(t=>{if((0,r.\u0275getAsyncClassMetadataFn)(t))throw new Error(`Component '${t.name}' has unresolved metadata. Please call \`await TestBed.compileComponents()\` before running this test.`);e=e||(0,r.\u0275isComponentDefPendingResolution)(t);const n=this.resolvers.component.resolve(t);if(n===null)throw j(t.name,"Component");this.maybeStoreNgDef(r.\u0275NG_COMP_DEF,t),r.\u0275USE_RUNTIME_DEPS_TRACKER_FOR_JIT&&r.\u0275depsTracker.clearScopeCacheFor(t),(0,r.\u0275compileComponent)(t,n)}),this.pendingComponents.clear(),this.pendingDirectives.forEach(t=>{const n=this.resolvers.directive.resolve(t);if(n===null)throw j(t.name,"Directive");this.maybeStoreNgDef(r.\u0275NG_DIR_DEF,t),(0,r.\u0275compileDirective)(t,n)}),this.pendingDirectives.clear(),this.pendingPipes.forEach(t=>{const n=this.resolvers.pipe.resolve(t);if(n===null)throw j(t.name,"Pipe");this.maybeStoreNgDef(r.\u0275NG_PIPE_DEF,t),(0,r.\u0275compilePipe)(t,n)}),this.pendingPipes.clear(),e}applyTransitiveScopes(){if(this.overriddenModules.size>0){const n=this.testModuleType[r.\u0275NG_MOD_DEF],o=this.collectModulesAffectedByOverrides(n.imports);o.size>0&&o.forEach(i=>{r.\u0275USE_RUNTIME_DEPS_TRACKER_FOR_JIT?r.\u0275depsTracker.clearScopeCacheFor(i):(this.storeFieldOfDefOnType(i,r.\u0275NG_MOD_DEF,"transitiveCompileScopes"),i[r.\u0275NG_MOD_DEF].transitiveCompileScopes=null)})}const e=new Map,t=n=>{if(!e.has(n)){const i=Me(n)?this.testModuleType:n;e.set(n,(0,r.\u0275transitiveScopesFor)(i))}return e.get(n)};this.componentToModuleScope.forEach((n,o)=>{if(n!==null){const i=t(n);this.storeFieldOfDefOnType(o,r.\u0275NG_COMP_DEF,"directiveDefs"),this.storeFieldOfDefOnType(o,r.\u0275NG_COMP_DEF,"pipeDefs"),(0,r.\u0275patchComponentDefWithScope)(b(o),i)}this.storeFieldOfDefOnType(o,r.\u0275NG_COMP_DEF,"tView")}),this.componentToModuleScope.clear()}applyProviderOverrides(){const e=t=>n=>{const i=(t===r.\u0275NG_COMP_DEF?this.resolvers.component:this.resolvers.directive).resolve(n);this.hasProviderOverrides(i.providers)&&this.patchDefWithProviderOverrides(n,t)};this.seenComponents.forEach(e(r.\u0275NG_COMP_DEF)),this.seenDirectives.forEach(e(r.\u0275NG_DIR_DEF)),this.seenComponents.clear(),this.seenDirectives.clear()}applyProviderOverridesInScope(e){if(!(k(e)||De(e))||this.scopesWithOverriddenProviders.has(e))return;this.scopesWithOverriddenProviders.add(e);const n=e[r.\u0275NG_INJ_DEF];if(this.providerOverridesByToken.size!==0)if(k(e)){const o=b(e),i=E(o.dependencies??[]);for(const c of i)this.applyProviderOverridesInScope(c)}else{const o=[...n.providers,...this.providerOverridesByModule.get(e)||[]];this.hasProviderOverrides(o)&&(this.maybeStoreNgDef(r.\u0275NG_INJ_DEF,e),this.storeFieldOfDefOnType(e,r.\u0275NG_INJ_DEF,"providers"),n.providers=this.getOverriddenProviders(o));const i=e[r.\u0275NG_MOD_DEF],c=E(i.imports);for(const a of c)this.applyProviderOverridesInScope(a);for(const a of Z(n.imports))Q(a)&&(this.defCleanupOps.push({object:a,fieldName:"providers",originalValue:a.providers}),a.providers=this.getOverriddenProviders(a.providers))}}patchComponentsWithExistingStyles(){this.existingComponentStyles.forEach((e,t)=>t[r.\u0275NG_COMP_DEF].styles=e),this.existingComponentStyles.clear()}queueTypeArray(e,t){for(const n of e)Array.isArray(n)?this.queueTypeArray(n,t):this.queueType(n,t)}recompileNgModule(e,t){this.maybeStoreNgDef(r.\u0275NG_MOD_DEF,e),this.maybeStoreNgDef(r.\u0275NG_INJ_DEF,e),(0,r.\u0275compileNgModuleDefs)(e,t)}maybeRegisterComponentWithAsyncMetadata(e){(0,r.\u0275getAsyncClassMetadataFn)(e)&&this.componentsWithAsyncMetadata.add(e)}queueType(e,t){if(this.maybeRegisterComponentWithAsyncMetadata(e),this.resolvers.component.resolve(e)){((0,r.\u0275isComponentDefPendingResolution)(e)||!e.hasOwnProperty(r.\u0275NG_COMP_DEF))&&this.pendingComponents.add(e),this.seenComponents.add(e),(!this.componentToModuleScope.has(e)||this.componentToModuleScope.get(e)===C.DECLARATION)&&this.componentToModuleScope.set(e,t);return}if(this.resolvers.directive.resolve(e)){e.hasOwnProperty(r.\u0275NG_DIR_DEF)||this.pendingDirectives.add(e),this.seenDirectives.add(e);return}if(this.resolvers.pipe.resolve(e)&&!e.hasOwnProperty(r.\u0275NG_PIPE_DEF)){this.pendingPipes.add(e);return}}queueTypesFromModulesArray(e){const t=new Set,n=o=>{for(const i of o)if(Array.isArray(i))n(i);else if(I(i)){const c=i.\u0275mod;if(t.has(c))continue;t.add(c),this.queueTypeArray(E(c.declarations),i),n(E(c.imports)),n(E(c.exports))}else if(Q(i))n([i.ngModule]);else if(k(i)){this.queueType(i,null);const c=b(i);if(t.has(c))continue;t.add(c),E(c.dependencies??[]).forEach(u=>{k(u)||I(u)?n([u]):this.queueType(u,null)})}};n(e)}collectModulesAffectedByOverrides(e){const t=new Set,n=new Set,o=(i,c)=>{for(const a of i)if(Array.isArray(a))o(a,c);else if(I(a)){if(t.has(a)){n.has(a)&&c.forEach(y=>n.add(y));continue}t.add(a),this.overriddenModules.has(a)&&c.forEach(y=>n.add(y));const u=a[r.\u0275NG_MOD_DEF];o(E(u.imports),c.concat(a))}};return o(e,[]),n}maybeStoreNgDef(e,t){this.initialNgDefs.has(t)||this.initialNgDefs.set(t,new Map);const n=this.initialNgDefs.get(t);if(!n.has(e)){const o=Object.getOwnPropertyDescriptor(t,e);n.set(e,o)}}storeFieldOfDefOnType(e,t,n){const o=e[t],i=o[n];this.defCleanupOps.push({object:o,fieldName:n,originalValue:i})}clearComponentResolutionQueue(){this.originalComponentResolutionQueue===null&&(this.originalComponentResolutionQueue=new Map),(0,r.\u0275clearResolutionOfComponentResourcesQueue)().forEach((e,t)=>this.originalComponentResolutionQueue.set(t,e))}restoreComponentResolutionQueue(){this.originalComponentResolutionQueue!==null&&((0,r.\u0275restoreComponentResolutionQueue)(this.originalComponentResolutionQueue),this.originalComponentResolutionQueue=null)}restoreOriginalState(){J(this.defCleanupOps,e=>{e.object[e.fieldName]=e.originalValue}),this.initialNgDefs.forEach((e,t)=>{r.\u0275USE_RUNTIME_DEPS_TRACKER_FOR_JIT&&r.\u0275depsTracker.clearScopeCacheFor(t),e.forEach((n,o)=>{n?Object.defineProperty(t,o,n):delete t[o]})}),this.initialNgDefs.clear(),this.scopesWithOverriddenProviders.clear(),this.restoreComponentResolutionQueue(),(0,r.\u0275setLocaleId)(r.\u0275DEFAULT_LOCALE_ID)}compileTestModule(){class e{}(0,r.\u0275compileNgModuleDefs)(e,{providers:[...this.rootProviderOverrides,(0,r.\u0275internalProvideZoneChangeDetection)({}),O,{provide:r.\u0275INTERNAL_APPLICATION_ERROR_HANDLER,useFactory:()=>{if((0,r.inject)(r.\u0275ZONELESS_ENABLED)||(0,r.inject)(G,{optional:!0})){const o=(0,r.inject)(O);return i=>{o.handleError(i)}}else{const o=(0,r.inject)(r.ErrorHandler),i=(0,r.inject)(r.NgZone);return c=>i.runOutsideAngular(()=>o.handleError(c))}}},{provide:r.\u0275ChangeDetectionScheduler,useExisting:r.\u0275ChangeDetectionSchedulerImpl}]});const t=[{provide:r.Compiler,useFactory:()=>new Ae(this)},{provide:r.\u0275DEFER_BLOCK_CONFIG,useValue:{behavior:this.deferBlockBehavior}},...this.providers,...this.providerOverrides],n=[e,this.additionalModuleTypes,this.imports||[]];(0,r.\u0275compileNgModuleDefs)(this.testModuleType,{declarations:this.declarations,imports:n,schemas:this.schemas,providers:t},!0),this.applyProviderOverridesInScope(this.testModuleType)}get injector(){if(this._injector!==null)return this._injector;const e=[];return this.platform.injector.get(r.COMPILER_OPTIONS).forEach(n=>{n.providers&&e.push(n.providers)}),this.compilerProviders!==null&&e.push(...this.compilerProviders),this._injector=r.Injector.create({providers:e,parent:this.platform.injector}),this._injector}getSingleProviderOverrides(e){const t=K(e);return this.providerOverridesByToken.get(t)||null}getProviderOverrides(e){return!e||!e.length||this.providerOverridesByToken.size===0?[]:Z(W(e,t=>this.getSingleProviderOverrides(t)||[]))}getOverriddenProviders(e){if(!e||!e.length||this.providerOverridesByToken.size===0)return[];const t=W(e),n=this.getProviderOverrides(t),o=[...t,...n],i=[],c=new Set;return J(o,a=>{const u=K(a);this.providerOverridesByToken.has(u)?c.has(u)||(c.add(u),i.unshift({...a,multi:!1})):i.unshift(a)}),i}hasProviderOverrides(e){return this.getProviderOverrides(e).length>0}patchDefWithProviderOverrides(e,t){const n=e[t];if(n&&n.providersResolver){this.maybeStoreNgDef(t,e);const o=n.providersResolver,i=c=>this.getOverriddenProviders(c);this.storeFieldOfDefOnType(e,t,"providersResolver"),n.providersResolver=c=>o(c,i)}}}function ye(){return{module:new Te,component:new Ce,directive:new Oe,pipe:new we}}function k(s){return!!b(s)?.standalone}function b(s){return s.\u0275cmp??null}function I(s){return s.hasOwnProperty("\u0275mod")}function De(s){return I(s)}function E(s){return s instanceof Function?s():s}function Z(s){const e=[];return s.forEach(t=>{Array.isArray(t)?e.push(...Z(t)):e.push(t)}),e}function Re(s){return s}function W(s,e=Re){const t=[];for(let n of s)(0,r.\u0275isEnvironmentProviders)(n)&&(n=n.\u0275providers),Array.isArray(n)?t.push(...W(n,e)):t.push(e(n));return t}function Ne(s,e){return s&&typeof s=="object"&&s[e]}function K(s){return Ne(s,"provide")||s}function Q(s){return s.hasOwnProperty("ngModule")}function J(s,e){for(let t=s.length-1;t>=0;t--)e(s[t],t)}function j(s,e){return new Error(`${s} class doesn't have @${e} decorator or is missing metadata.`)}class Ae{constructor(e){this.testBed=e}compileModuleSync(e){return this.testBed._compileNgModuleSync(e),new r.\u0275NgModuleFactory(e)}compileModuleAsync(e){var t=this;return(0,m.A)(function*(){return yield t.testBed._compileNgModuleAsync(e),new r.\u0275NgModuleFactory(e)})()}compileModuleAndAllComponentsSync(e){const t=this.compileModuleSync(e),n=this.testBed._getComponentFactories(e);return new r.ModuleWithComponentFactories(t,n)}compileModuleAndAllComponentsAsync(e){var t=this;return(0,m.A)(function*(){const n=yield t.compileModuleAsync(e),o=t.testBed._getComponentFactories(e);return new r.ModuleWithComponentFactories(n,o)})()}clearCache(){}clearCacheFor(e){}getModuleId(e){const t=this.testBed._getModuleResolver().resolve(e);return t&&t.id||void 0}}let Se=0;function Pe(){return l.INSTANCE}class l{constructor(){this._instanceDeferBlockBehavior=N,this.platform=null,this.ngModule=null,this._compiler=null,this._testModuleRef=null,this._activeFixtures=[],this.globalCompilationChecked=!1}static{this._INSTANCE=null}static get INSTANCE(){return l._INSTANCE=l._INSTANCE||new l}static initTestEnvironment(e,t,n){const o=l.INSTANCE;return o.initTestEnvironment(e,t,n),o}static resetTestEnvironment(){l.INSTANCE.resetTestEnvironment()}static configureCompiler(e){return l.INSTANCE.configureCompiler(e)}static configureTestingModule(e){return l.INSTANCE.configureTestingModule(e)}static compileComponents(){return l.INSTANCE.compileComponents()}static overrideModule(e,t){return l.INSTANCE.overrideModule(e,t)}static overrideComponent(e,t){return l.INSTANCE.overrideComponent(e,t)}static overrideDirective(e,t){return l.INSTANCE.overrideDirective(e,t)}static overridePipe(e,t){return l.INSTANCE.overridePipe(e,t)}static overrideTemplate(e,t){return l.INSTANCE.overrideTemplate(e,t)}static overrideTemplateUsingTestingModule(e,t){return l.INSTANCE.overrideTemplateUsingTestingModule(e,t)}static overrideProvider(e,t){return l.INSTANCE.overrideProvider(e,t)}static inject(e,t,n){return l.INSTANCE.inject(e,t,(0,r.\u0275convertToBitFlags)(n))}static get(e,t=r.Injector.THROW_IF_NOT_FOUND,n=r.InjectFlags.Default){return l.INSTANCE.inject(e,t,n)}static runInInjectionContext(e){return l.INSTANCE.runInInjectionContext(e)}static createComponent(e){return l.INSTANCE.createComponent(e)}static resetTestingModule(){return l.INSTANCE.resetTestingModule()}static execute(e,t,n){return l.INSTANCE.execute(e,t,n)}static get platform(){return l.INSTANCE.platform}static get ngModule(){return l.INSTANCE.ngModule}static flushEffects(){return l.INSTANCE.flushEffects()}initTestEnvironment(e,t,n){if(this.platform||this.ngModule)throw new Error("Cannot set base providers because it has already been called");l._environmentTeardownOptions=n?.teardown,l._environmentErrorOnUnknownElementsOption=n?.errorOnUnknownElements,l._environmentErrorOnUnknownPropertiesOption=n?.errorOnUnknownProperties,this.platform=t,this.ngModule=e,this._compiler=new H(this.platform,this.ngModule),(0,r.\u0275setAllowDuplicateNgModuleIdsForTest)(!0)}resetTestEnvironment(){this.resetTestingModule(),this._compiler=null,this.platform=null,this.ngModule=null,l._environmentTeardownOptions=void 0,(0,r.\u0275setAllowDuplicateNgModuleIdsForTest)(!1)}resetTestingModule(){this.checkGlobalCompilationFinished(),(0,r.\u0275resetCompiledComponents)(),this._compiler!==null&&this.compiler.restoreOriginalState(),this._compiler=new H(this.platform,this.ngModule),(0,r.\u0275setUnknownElementStrictMode)(this._previousErrorOnUnknownElementsOption??v),(0,r.\u0275setUnknownPropertyStrictMode)(this._previousErrorOnUnknownPropertiesOption??S);try{this.destroyActiveFixtures()}finally{try{this.shouldTearDownTestingModule()&&this.tearDownTestingModule()}finally{this._testModuleRef=null,this._instanceTeardownOptions=void 0,this._instanceErrorOnUnknownElementsOption=void 0,this._instanceErrorOnUnknownPropertiesOption=void 0,this._instanceDeferBlockBehavior=N}}return this}configureCompiler(e){if(e.useJit!=null)throw new Error("JIT compiler is not configurable via TestBed APIs.");return e.providers!==void 0&&this.compiler.setCompilerProviders(e.providers),this}configureTestingModule(e){return this.assertNotInstantiated("TestBed.configureTestingModule","configure the test module"),this.checkGlobalCompilationFinished(),this._instanceTeardownOptions=e.teardown,this._instanceErrorOnUnknownElementsOption=e.errorOnUnknownElements,this._instanceErrorOnUnknownPropertiesOption=e.errorOnUnknownProperties,this._instanceDeferBlockBehavior=e.deferBlockBehavior??N,this._previousErrorOnUnknownElementsOption=(0,r.\u0275getUnknownElementStrictMode)(),(0,r.\u0275setUnknownElementStrictMode)(this.shouldThrowErrorOnUnknownElements()),this._previousErrorOnUnknownPropertiesOption=(0,r.\u0275getUnknownPropertyStrictMode)(),(0,r.\u0275setUnknownPropertyStrictMode)(this.shouldThrowErrorOnUnknownProperties()),this.compiler.configureTestingModule(e),this}compileComponents(){return this.compiler.compileComponents()}inject(e,t,n){if(e===q)return this;const o={},i=this.testModuleRef.injector.get(e,o,(0,r.\u0275convertToBitFlags)(n));return i===o?this.compiler.injector.get(e,t,n):i}get(e,t=r.Injector.THROW_IF_NOT_FOUND,n=r.InjectFlags.Default){return this.inject(e,t,n)}runInInjectionContext(e){return(0,r.runInInjectionContext)(this.inject(r.EnvironmentInjector),e)}execute(e,t,n){const o=e.map(i=>this.inject(i));return t.apply(n,o)}overrideModule(e,t){return this.assertNotInstantiated("overrideModule","override module metadata"),this.compiler.overrideModule(e,t),this}overrideComponent(e,t){return this.assertNotInstantiated("overrideComponent","override component metadata"),this.compiler.overrideComponent(e,t),this}overrideTemplateUsingTestingModule(e,t){return this.assertNotInstantiated("TestBed.overrideTemplateUsingTestingModule","Cannot override template when the test module has already been instantiated"),this.compiler.overrideTemplateUsingTestingModule(e,t),this}overrideDirective(e,t){return this.assertNotInstantiated("overrideDirective","override directive metadata"),this.compiler.overrideDirective(e,t),this}overridePipe(e,t){return this.assertNotInstantiated("overridePipe","override pipe metadata"),this.compiler.overridePipe(e,t),this}overrideProvider(e,t){return this.assertNotInstantiated("overrideProvider","override provider"),this.compiler.overrideProvider(e,t),this}overrideTemplate(e,t){return this.overrideComponent(e,{set:{template:t,templateUrl:null}})}createComponent(e){const t=this.inject(U),n=`root${Se++}`;if(t.insertRootElement(n),(0,r.\u0275getAsyncClassMetadataFn)(e))throw new Error(`Component '${e.name}' has unresolved metadata. Please call \`await TestBed.compileComponents()\` before running this test.`);const o=e.\u0275cmp;if(!o)throw new Error(`It looks like '${(0,r.\u0275stringify)(e)}' has not been compiled.`);const i=new r.\u0275Render3ComponentFactory(o),c=()=>{const te=i.create(r.Injector.NULL,[],`#${n}`,this.testModuleRef);return this.runInInjectionContext(()=>{const ne=this.inject(r.\u0275ZONELESS_ENABLED)?new oe(te):new se(te);return ne.initialize(),ne})},u=this.inject(x,!1)?null:this.inject(r.NgZone,null),y=u?u.run(c):c();return this._activeFixtures.push(y),y}get compiler(){if(this._compiler===null)throw new Error("Need to call TestBed.initTestEnvironment() first");return this._compiler}get testModuleRef(){return this._testModuleRef===null&&(this._testModuleRef=this.compiler.finalize()),this._testModuleRef}assertNotInstantiated(e,t){if(this._testModuleRef!==null)throw new Error(`Cannot ${t} when the test module has already been instantiated. Make sure you are not using \`inject\` before \`${e}\`.`)}checkGlobalCompilationFinished(){!this.globalCompilationChecked&&this._testModuleRef===null&&(0,r.\u0275flushModuleScopingQueueAsMuchAsPossible)(),this.globalCompilationChecked=!0}destroyActiveFixtures(){let e=0;if(this._activeFixtures.forEach(t=>{try{t.destroy()}catch(n){e++,console.error("Error during cleanup of component",{component:t.componentInstance,stacktrace:n})}}),this._activeFixtures=[],e>0&&this.shouldRethrowTeardownErrors())throw Error(`${e} ${e===1?"component":"components"} threw errors during cleanup`)}shouldRethrowTeardownErrors(){const e=this._instanceTeardownOptions,t=l._environmentTeardownOptions;return!e&&!t?g:e?.rethrowErrors??t?.rethrowErrors??this.shouldTearDownTestingModule()}shouldThrowErrorOnUnknownElements(){return this._instanceErrorOnUnknownElementsOption??l._environmentErrorOnUnknownElementsOption??v}shouldThrowErrorOnUnknownProperties(){return this._instanceErrorOnUnknownPropertiesOption??l._environmentErrorOnUnknownPropertiesOption??S}shouldTearDownTestingModule(){return this._instanceTeardownOptions?.destroyAfterEach??l._environmentTeardownOptions?.destroyAfterEach??g}getDeferBlockBehavior(){return this._instanceDeferBlockBehavior}tearDownTestingModule(){if(this._testModuleRef===null)return;const e=this.inject(U);try{this._testModuleRef.destroy()}catch(t){if(this.shouldRethrowTeardownErrors())throw t;console.error("Error during cleanup of a testing module",{component:this._testModuleRef.instance,stacktrace:t})}finally{e.removeAllRootElements?.()}}flushEffects(){this.inject(r.\u0275EffectScheduler).flush()}}const q=l;function Y(s,e){const t=l.INSTANCE;return function(){return t.execute(s,e,this)}}class X{constructor(e){this._moduleDef=e}_addModule(){const e=this._moduleDef();e&&l.configureTestingModule(e)}inject(e,t){const n=this;return function(){return n._addModule(),Y(e,t).call(this)}}}function Fe(s,e){return e?function(){const t=l.INSTANCE;return s&&t.configureTestingModule(s),e.apply(this)}:new X(()=>s)}globalThis.beforeEach?.(ee(!1)),globalThis.afterEach?.(ee(!0));function ee(s){return()=>{const e=l.INSTANCE;e.shouldTearDownTestingModule()===s&&(e.resetTestingModule(),ce())}}const ke=""},73308:(re,A,h)=>{h.d(A,{A:()=>m});function p(r,D,R,w,f,T,_){try{var g=r[T](_),v=g.value}catch(S){return void R(S)}g.done?D(v):Promise.resolve(v).then(w,f)}function m(r){return function(){var D=this,R=arguments;return new Promise(function(w,f){var T=r.apply(D,R);function _(v){p(T,w,f,_,g,"next",v)}function g(v){p(T,w,f,_,g,"throw",v)}_(void 0)})}}}}]);
